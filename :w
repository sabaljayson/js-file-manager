var React = require('react');

var AreaSelect = params => element => {
  class AreaSelectComponent extends React.Component {
    componentDidMount() {
      this.container = $(this.refs.container.getDOMNode());
      this.containerWidth = this.container.width();
      this.rectNode = null;

      this.selectableElems = $(this.container)
        .find(params.selectors.join())
        .toArray();
 
      this.container.off('mousedown');
      this.container.off('mousemove');
      this.container.off('mouseup');
      this.container.off('mouseleave');
      
      this.container.on('mousedown', this.onMouseDown.bind(this));
      this.container.on('mousemove', this.onMouseMove.bind(this));
      this.container.on('mouseup', this.onMouseUp.bind(this));
      this.container.on('mouseleave', this.onMouseOut.bind(this));
    }

    render() {
      return React.cloneElement(element, {ref: 'container'});
    }
    
    onMouseDown(e) {
      if (e.which !== 1) // 1 == left button
        return;

      this.rectNode = this.createRectNode();
      this.x = e.pageX;
      this.y = e.pageY + this.container.scrollTop(); 
      
      params.elemTypes.forEach(el => el.ids.forEach(params.unselectElem));
      e.preventDefault()
    }

    onMouseMove(e) {
      if (! this.rectNode)
        return;
    
      var selectRect = rectangleCoords(this.x, this.y, e.pageX, e.pageY + this.container.scrollTop());
      this.drawRect(selectRect);
    }

    onMouseUp(e) {
      $(this.rectNode).remove();
      this.rectNode = null;
    }

    onMouseOut(e) {
     this.onMouseUp(e);
    }
    
    dotIsInAnyElement(x, y) {
      var scrollTop = container.scrollTop(),
        scrollBottom = scrollTop + window.innerHeight;

      var dotRect = rectangleCoords(x, y + scrollTop, x + 1, y + scrollTop + 1);

      for (var i = 0; i < selectableElems.length; ++i) {
        var $node = $(selectableElems[i]);
        var pos = $node.offset();

        pos.top += container.scrollTop();

        if (scrollTop <= pos.top && pos.top <= scrollBottom) {
          var width = $node.outerWidth();
          var height = $node.outerHeight();                     

          var elementRect = rectangleCoords(pos.left, pos.top, pos.left + width, pos.top + height);

          if (rectsIntersect(dotRect, elementRect)) {
            return true;
          }
        }
      }

      return false;
    }
    
    callOnIntersect(selectRect) {
      var scrollTop = container.scrollTop(),
        scrollBottom = scrollTop + window.innerHeight;

      selectableElems.forEach(function(node) {
        var $node = $(node);
        var pos = $node.offset();

        pos.top += scrollTop;

        var nodeInView = pos.top <= scrollBottom;
        var nodeInSelect = selectRect.y1 <= pos.top && pos.top <= selectRect.y2;

        if (nodeInView || nodeInSelect) {
          var width = $node.outerWidth();
          var height = $node.outerHeight();

          var elementRect = rectangleCoords(pos.left, pos.top, pos.left + width, pos.top + height);

          if (rectsIntersect(selectRect, elementRect)) {
            nodeSelected[node.id] = true;
            options.enterArea(node);
          }
          else if (nodeSelected[node.id]) {
            nodeSelected[node.id] = false;
            options.exitArea(node);
          }
        }
      });
    }
 
    createRectNode() {
      var rectNode = $('<div/>');
      rectNode.css({
        'position': 'fixed',
        'top': 0,
        'left': 0,
        'width': 0,
        'height': 0
      });
      rectNode.addClass('area-select');

      this.container.append(rectNode);
      return rectNode.get(0);
    }
    
    drawRect(rect) {
      $(this.rectNode).css({
        'top': rect.y0 - this.container.scrollTop(),
        'left': rect.x0,
        'width': rect.x1 - rect.x0,
        'height': rect.y1 - rect.y0
      });
    }
  }

  return <AreaSelectComponent/>
};

module.exports = AreaSelect;

function rectangleCoords(x0, y0, x1, y1) {
  var minX = Math.min(x0, x1),
    minY = Math.min(y0, y1),
    maxX = Math.max(x0, x1),
    maxY = Math.max(y0, y1);

  return {
    x0: minX,
    x1: maxX,
    y0: minY,
    y1: maxY
  };
}
